{"java":"/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\r\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\r\n        if(root == null) return result;\r\n        Stack<TreeNode> stParent = new Stack<TreeNode>();\r\n        stParent.push(root);\r\n        //因为z型遍历的时候需要调换加入栈中的顺序,前一遍是先加左节点,后一便就会反过来变成先加右节点\r\n        //所以需要用这个boolean来记录当前是改左还是右.\r\n        boolean leftOrRight = true;\r\n        while(!stParent.empty()){\r\n            Stack<TreeNode> stChild =new Stack<TreeNode>();\r\n            ArrayList<Integer> curResult = new ArrayList<Integer>();\r\n            while(!stParent.empty()){\r\n                TreeNode cur = stParent.pop();\r\n                curResult.add(cur.val);\r\n                if(leftOrRight){\r\n                    if(cur.left != null) stChild.push(cur.left);\r\n                    if(cur.right != null) stChild.push(cur.right);\r\n                }else{\r\n                    if(cur.right != null) stChild.push(cur.right);\r\n                    if(cur.left != null) stChild.push(cur.left);\r\n                }\r\n            }\r\n            result.add(curResult);\r\n            leftOrRight = !leftOrRight;\r\n            stParent = stChild;\r\n        }\r\n        return result;\r\n    }\r\n}"}