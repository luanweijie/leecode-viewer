{"java":"/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    //这道题没有做出来 \r\n    //但其实要是对二叉树的先/中/后序遍历掌握比较清楚,对其意义比较了解的话,其实做起来很简单的\r\n    //一个BST 用中序遍历就可以将它扁平化,拉直成为一个排好序的数组,\r\n    //明白了这一点,这个题就好做了,\r\n    //2 elements are swapped 那就是去一个有两个元素被调换顺序的数组中找到这两个元素\r\n    //这不就简单啦?\r\n    //用constant space的话那就不要递归了 改成循环就可以了\r\n    public void recoverTree(TreeNode root) {\r\n        TreeNode now = root;\r\n        Stack<TreeNode> st = new Stack<TreeNode>();\r\n        TreeNode mistake1 = null,mistake2 = null;\r\n        TreeNode prev = null;\r\n        int i = 0;\r\n        while(now != null || !st.empty()){\r\n            if(now != null){\r\n                st.push(now);\r\n                now = now.left;\r\n            }else{\r\n                now = st.pop();\r\n                if(i == 0){\r\n                    i++;\r\n                }else{\r\n                    if(now.val < prev.val){\r\n                        if(mistake2 == null){\r\n                            mistake1 = prev;\r\n                            mistake2 = now;\r\n                        }else{\r\n                            mistake2 = now;\r\n                        }\r\n                    }\r\n                }\r\n                prev = now;\r\n                now = now.right;\r\n            }\r\n        }\r\n        int temp = mistake1.val;\r\n        mistake1.val = mistake2.val;\r\n        mistake2.val = temp;\r\n    }\r\n}"}