{"java":"public class Solution {\r\n    //ac了 可是速度好慢啊\r\n    //具体就是求出以第i条边为container的一条边时 容量的最大值\r\n    //对于另外一条边j 如果高于第i条边 那么面积等于他们x轴的距离乘以height[i]\r\n    //如果低于第i条边 那么面积等于他们x轴的距离乘以height[j]\r\n    //很显然 对于另一条低于第i条边的情况我们要计算出height[j]*x轴距离\r\n    //而对于高于的情况 只用考虑让x轴距离最大就可以了 因为反正最后都是乘以height[i]\r\n    //所以思想上来说只用去找比当前i边高的j边 让j与i在x轴距离最大即可,\r\n    //因为两条边作为容器的边,我们只用考虑那条较矮的边为i边较高的边为j边即可不然就重复计算了.\r\n    public class Node{\r\n        int height;\r\n        int position;\r\n        Node(int h, int p){\r\n            height = h;\r\n            position = p;\r\n        }\r\n    }\r\n    public void quickSort(Node[] nodeList,int start,int end){\r\n        //对节点列表快排\r\n        int midNum = ((end - start + 1)/2) +start;\r\n        Node temp = nodeList[midNum];\r\n        nodeList[midNum] = nodeList[start];\r\n        nodeList[start] = temp;\r\n        Node pivotNode = nodeList[start];\r\n        int front = start,tail = end;\r\n        while(front != tail){\r\n            while(nodeList[tail].height >= pivotNode.height && front != tail){\r\n                tail--;\r\n            }\r\n            nodeList[front] = nodeList[tail];\r\n            while(nodeList[front].height <= pivotNode.height && front != tail){\r\n                front++;\r\n            }\r\n            nodeList[tail] = nodeList[front];\r\n        }\r\n        nodeList[front] = pivotNode;\r\n        if(front -1 > start){\r\n            quickSort(nodeList,start,front-1);\r\n        }\r\n        if(front + 1 < end){\r\n            quickSort(nodeList,front+1,end);\r\n        }\r\n    }\r\n    public int maxArea(int[] height) {\r\n        if(height.length < 1){\r\n            return 0;\r\n        }\r\n        if(height.length == 2){\r\n            return height[0] > height[1]?height[1]:height[0];\r\n        }\r\n        Node[] nodeList = new Node[height.length];\r\n        for(int i = 0; i < height.length;i++){\r\n            nodeList[i] = new Node(height[i],i);\r\n        }\r\n        quickSort(nodeList,0,height.length-1);\r\n        int[] rank = new int[height.length];\r\n        // rank[i]记录从小到大排序height[i]排在第几;\r\n        for(int i = 0; i < height.length;i++){\r\n            rank[nodeList[i].position] = i;\r\n        }\r\n        //用rmq排序\r\n        int logNum = (int)(Math.log(rank.length)/Math.log(2));\r\n        int[][] rmq_max = new int[rank.length][logNum+1];\r\n        int[][] rmq_min = new int[rank.length][logNum+1];\r\n        for(int i = 0;i<rank.length;i++){\r\n            rmq_max[i][0] = nodeList[i].position;\r\n            rmq_min[i][0] = nodeList[i].position;\r\n        }\r\n        for(int j = 1;j <= logNum;j++){\r\n            for(int i = 0; i + (1 << j) -1 < rank.length; i++){\r\n                rmq_max[i][j] = rmq_max[i][j-1] > rmq_max[i + (1 << j-1)][j-1]?rmq_max[i][j-1]:rmq_max[i + (1 << j-1)][j-1];\r\n                rmq_min[i][j] = rmq_min[i][j-1] > rmq_min[i + (1 << j-1)][j-1]?rmq_min[i + (1 << j-1)][j-1]: rmq_min[i][j-1];\r\n            }\r\n        }\r\n        int maxArea = 0;\r\n        if(rank[0] != height.length -1 ){\r\n            int rankNum = rank[0];\r\n            int nodeRest = height.length - rankNum -1;\r\n            int restLog = (int)(Math.log(nodeRest)/Math.log(2));\r\n            int furthestPoint = Math.max(rmq_max[rankNum+1][restLog],rmq_max[height.length - (1 << restLog)][restLog]);\r\n            maxArea = furthestPoint * height[0];\r\n        }\r\n        for(int i = 0; i < height.length;i++){\r\n            int area = 0;\r\n            int rankNum = rank[i];\r\n            if(rank[i] != height.length -1 ){\r\n                int nodeRest = height.length - rankNum -1;\r\n                int restLog = (int)(Math.log(nodeRest)/Math.log(2));\r\n                int furthestRightPoint = Math.max(rmq_max[rankNum+1][restLog],rmq_max[height.length - (1 << restLog)][restLog]);\r\n                int furthestLeftPoint = Math.min(rmq_min[rankNum+1][restLog],rmq_min[height.length - (1 << restLog)][restLog]);\r\n                area = Math.max(Math.abs(furthestRightPoint - i),Math.abs(furthestLeftPoint - i))* height[i];\r\n                if(area > maxArea){\r\n                    maxArea = area;\r\n                }\r\n            }\r\n        }\r\n        return maxArea;\r\n    }\r\n}"}