{"java":"public class Solution {\r\n    public class Process {\r\n        int regStart = 0;\r\n        int regLen = 0;\r\n        int matchStart = 0;\r\n        int matchLen = 0;\r\n        Process(int st,int len,int mst,int mlen){\r\n            regStart = st;\r\n            regLen = len;\r\n            matchStart = mst;\r\n            matchLen = mlen;\r\n        }\r\n    }\r\n    public boolean isMatch(String s, String p){\r\n        if(s.length() == 0 ){\r\n            if(p.length() == 0){\r\n                return true;\r\n            }else if(p.length() == 1){\r\n                return false;\r\n            }\r\n            \r\n        }\r\n        char[] arrS = s.toCharArray();\r\n        char[] arrReg = p.toCharArray();\r\n        Stack processes = new Stack();\r\n        //这个processes栈用来记录匹配的过程,具体就是记录每个匹配单元匹配了arrS的哪一段;\r\n        //匹配单元是指\"x\" \".\" \"x*\" \".*\"这四种情况\r\n        //因为匹配的过程中\"x*\",\".*\"这两种匹配单元的可能匹配0到n个字符串所以需要记录下来\r\n        int regStart =0,matchStart=0,matchEnd = arrS.length - 1;\r\n        while(!(regStart == arrReg.length && matchStart == arrS.length)){\r\n            //总的思想就是匹配的时候先尽可能的往后匹配\r\n            //同时每次匹配都记录下匹配的片段,生成一个process压到processes里面去了\r\n            //如果后续匹配失败的话就调用popStack从processes找出某一个可减少匹配长度的process,而在找出之前遇到的不能减少匹配长度的process就从processes吐出来扔掉\r\n            //然后减少这个可减少匹配长度的process的匹配长度,继续往后匹配\r\n            //如此往复,直至processes栈里面没有可减少匹配长度的process 那就匹配失败了\r\n            if(regStart == arrReg.length ){\r\n                return false;\r\n            }else if(matchStart == arrS.length){\r\n                if(regStart+1 < arrReg.length && arrReg[regStart+1] == '*'){\r\n                    processes.push(new Process(regStart,2,matchStart,0));\r\n                    regStart += 2;\r\n                }else{\r\n                    Process changeablePrcs = popStack(processes);\r\n                    if(changeablePrcs != null){\r\n                        changeablePrcs.matchLen--;\r\n                        regStart = changeablePrcs.regStart;\r\n                        matchStart = changeablePrcs.matchStart;\r\n                        matchEnd = changeablePrcs.matchLen-1+matchStart;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                }\r\n            } else{\r\n                if(isRightChar(arrReg[regStart])){\r\n                    if(regStart+1 < arrReg.length && arrReg[regStart+1] == '*'){\r\n                        char[] regUnit = {arrReg[regStart],arrReg[regStart+1]};\r\n                        int matchResult = match(arrS,regUnit,matchStart,matchEnd);\r\n                        processes.push(new Process(regStart,2,matchStart,matchResult));\r\n                        regStart += 2;\r\n                        matchStart += matchResult;\r\n                        matchEnd = arrS.length - 1;\r\n                    }else{\r\n                        char[] regUnit = {arrReg[regStart]};\r\n                        int matchResult = match(arrS,regUnit,matchStart,matchEnd);\r\n                        if(matchResult > 0){\r\n                            processes.push(new Process(regStart,1,matchStart,matchResult));\r\n                            regStart++;\r\n                            matchStart += matchResult;\r\n                        }else{\r\n                            Process changeablePrcs = popStack(processes);\r\n                            if(changeablePrcs != null){\r\n                                changeablePrcs.matchLen--;\r\n                                regStart = changeablePrcs.regStart;\r\n                                matchStart = changeablePrcs.matchStart;\r\n                                matchEnd = changeablePrcs.matchLen-1+matchStart;\r\n                            }else{\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    public boolean isRightChar(char a){\r\n        if((a >= 65 && a <= 90) || (a >= 97 && a <= 122) || a == '.'){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    public int match(char[] arrS,char[] arrReg,int start,int end){\r\n        //用于查询arrS从start到end位置(闭区间)是否有能被arrReg匹配上的字符串\r\n        //char[] arrReg是因为有的时候要匹配'a*','.*'这样的\r\n        //返回被匹配的长度,\r\n        if(end < start){\r\n            return 0;\r\n        }\r\n        if(arrReg.length == 1){\r\n            if(arrReg[0] == '.'){\r\n                return (arrS[start] >= 65 && arrS[start] <= 90) || (arrS[start] >= 97 && arrS[start] <= 122)? 1:0;\r\n            }else{\r\n                return arrS[start] == arrReg[0] ? 1:0;\r\n            }\r\n        }else{\r\n            int len = 0;\r\n            if(arrReg[0] == '.'){\r\n                for(;start <= end;start++){\r\n                    if((arrS[start] >= 65 && arrS[start] <= 90) || (arrS[start] >= 97 && arrS[start] <= 122)){\r\n                        len++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }else{\r\n                for(;start <= end;start++){\r\n                    if(arrS[start] == arrReg[0]){\r\n                        len++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            return len;\r\n        }\r\n    }\r\n    public Process popStack(Stack processes){\r\n        //这个函数用于从processes栈里面找出某一个可减少匹配长度的process\r\n        //什么意思? 意思是某一个正则匹配单元比如\".*\"\r\n        //假如在之前匹配的时候它匹配的是\"abcd\",然后导致了后面的匹配失败了\r\n        //现在我可以让他只匹配\"abc\",然后看看后面的匹配能不能成功\r\n        Process prcs = null;\r\n        while(!processes.empty()){\r\n            Process curPrcs = (Process)processes.pop();\r\n            if(curPrcs.regLen == 2 && curPrcs.matchLen != 0){\r\n                prcs = curPrcs;\r\n                break;\r\n            }\r\n        }\r\n        return prcs;\r\n    }\r\n}"}