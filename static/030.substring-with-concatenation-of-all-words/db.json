{"java":"public class Solution {\r\n    class Node {\r\n        int position;\r\n        int count;\r\n        Node(int p,int c){\r\n            position = p;\r\n            count = c;\r\n        }\r\n    }\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        HashMap map = new HashMap();\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        int len = words[0].length();\r\n        for(int i = 0; i < words.length;i++){\r\n            if(map.get(words[i]) == null){\r\n                Node newNode = new Node(i,1);\r\n                map.put(words[i],newNode);\r\n            }else{\r\n                Node oldNode = (Node)map.get(words[i]);\r\n                oldNode.count++;\r\n            }\r\n        }\r\n        int[] leftMatchedOfPos = new int[words.length];\r\n        //记录words中该位置还可以match几次\r\n        for(int j = 0; j + len*words.length <= s.length(); j++){\r\n            Arrays.fill( leftMatchedOfPos, -1);\r\n            int i = j;\r\n            int countMatched = 0;\r\n            outLoop:while(countMatched < words.length){\r\n                String current = s.substring(i,i+len);\r\n                if(map.get(current) == null){\r\n                    break;\r\n                }\r\n                Node posAndCount = (Node)map.get(current);\r\n                switch(leftMatchedOfPos[posAndCount.position]){\r\n                    case -1:\r\n                        leftMatchedOfPos[posAndCount.position] = posAndCount.count - 1;\r\n                        break;\r\n                    case 0:\r\n                        break outLoop;\r\n                    default:\r\n                        leftMatchedOfPos[posAndCount.position]--;\r\n                        break;\r\n                }\r\n                countMatched++;\r\n                i+= len;\r\n            }\r\n            if(countMatched == words.length){\r\n                result.add(j);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}    "}