{"java":"/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public List<Integer> inorderTraversal(TreeNode root) {\r\n        ArrayList<Integer> result = new ArrayList<Integer>();\r\n        if(root == null) return result;\r\n        Stack<TreeNode> nodeToTraversal = new Stack<TreeNode>();\r\n        nodeToTraversal.push(root);\r\n        TreeNode cur;boolean left = true;\r\n        while(!nodeToTraversal.empty()){\r\n            cur = nodeToTraversal.peek();\r\n            if(left == true && cur.left != null){\r\n                nodeToTraversal.push(cur.left);\r\n            }else{\r\n                nodeToTraversal.pop();\r\n                result.add(cur.val);\r\n                if(cur.right != null){\r\n                    left = true;\r\n                    nodeToTraversal.push(cur.right);\r\n                }else{\r\n                    left = false;\r\n                }\r\n            }\r\n            \r\n        }\r\n        return result;\r\n    }\r\n    //下面是源神给的代码,代码更加精简优美,但是其实思路是一样的,\r\n    //我是用一个boolean来记录当前是否在一直遍历左枝 \r\n    //而源神的代码里是用了now是否等于null来标记左枝遍历的结束.\r\n//     public void traversal(TreeNode root) {\r\n// \t\tTreeNode now = root;\r\n// \t\tStack<TreeNode> stack = new Stack<TreeNode>();\r\n// \t\twhile (now != null || !stack.isEmpty()) {// 栈和当前指针都为null才算遍历完成\r\n// \t\t\tif (now != null) {// 一直向左枝走\r\n// \t\t\t\tstack.push(now);\r\n// \t\t\t\tnow = now.left;\r\n// \t\t\t} else {// 左枝走到头，访问当前节点，然后跳到右枝\r\n// \t\t\t\tnow = stack.pop();\r\n// \t\t\t\tSystem.out.println(now.val);// 访问该节点\r\n// \t\t\t\tnow = now.right;\r\n// \t\t\t}\r\n// \t\t}\r\n// \t}\r\n}"}